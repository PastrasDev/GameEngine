using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Vyrse.Analyzers.Syntax;

/// <summary>Immutable code fragment you can compose with + and implicit string.</summary>
public sealed class Code
{
	public string Text { get; }

	private Code(string text) => Text = text;

	public override string ToString() => Text;

	public static Code Of(string? s) => new(s ?? string.Empty);

	public static Code operator +(Code a, Code b)
	{
		if (string.IsNullOrEmpty(a.Text)) return b;
		if (string.IsNullOrEmpty(b.Text)) return a;

		bool leftEndsWithSpace = a.Text.EndsWith(" ");
		bool rightStartsWithSpace = b.Text.StartsWith(" ");

		string text = leftEndsWithSpace || rightStartsWithSpace ? a.Text + b.Text : a.Text + " " + b.Text;

		return new Code(text);
	}

	public static Code operator |(Code a, Code b) => new Code(a.Text + b.Text);

	public static implicit operator Code(string s) => Of(s);
	public static implicit operator string(Code c) => c.Text;
}

// Common tokens
public static class Keyword
{
	public static readonly Code @return = Code.Of("return");
	public static readonly Code @default = Code.Of("default");
	public static readonly Code @unsafe = Code.Of("unsafe");
	public static readonly Code @partial = Code.Of("partial");
	public static readonly Code @void = Code.Of("void");

	public static readonly Code @using = Code.Of("using");
	public static readonly Code global = Code.Of("global");
	public static readonly Code @namespace = Code.Of("namespace");
	public static readonly Code @class = Code.Of("class");
	public static readonly Code @public = Code.Of("public");
	public static readonly Code @static = Code.Of("static");
}

public static class Op
{
	public static readonly Code Empty = Code.Of("");
	public static readonly Code Exclamation = Code.Of("!");
	public static readonly Code Assign = Code.Of("=");
	public static readonly Code Semicolon = Code.Of(";");
	public static readonly Code Colon = Code.Of(":");
	public static readonly Code Comma = Code.Of(",");
	public static readonly Code Dot = Code.Of(".");
	public static readonly Code Amp = Code.Of("&");
	public static readonly Code Star = Code.Of("*");
	public static readonly Code NAQ = Code.Of("::");

	public static readonly Code Indent = "    ";
	public static readonly Code Eol = "\r\n";
}

public static class Punct
{
	public static readonly Code Space = Code.Of(" ");
	public static readonly Code Tab = Code.Of("\t");
	public static readonly Code LParen = Code.Of("(");
	public static readonly Code RParen = Code.Of(")");
	public static readonly Code LBrace = Code.Of("{");
	public static readonly Code RBrace = Code.Of("}");
	public static readonly Code LBracket = Code.Of("[");
	public static readonly Code RBracket = Code.Of("]");
	public static readonly Code NewLine = Code.Of("\n"); // analyzer-safe EOL
}

/// <summary>Prebuilt composites for convenience.</summary>
public static class Snippet
{
	public static readonly Code ReturnDefaultBangSemi = Keyword.@return + Punct.Space + Keyword.@default + Op.Exclamation + Op.Semicolon;

	public static Code UsingGlobal(string ns) => ("global using " + ns + ";");
}

/// <summary>Fluent builder with indentation, blocks, and line helpers.</summary>
public sealed class CodeBuilder
{
	private readonly StringBuilder _sb = new StringBuilder(1024);
	private int _indent;
	private readonly string _indentUnit;
	private readonly string _eol;

	public CodeBuilder(string indentUnit = "    ", string eol = "\n")
	{
		_indentUnit = indentUnit ?? "    ";
		_eol = eol ?? "\n"; // keep analyzer-safe, no Environment.NewLine
	}

	public override string ToString() => _sb.ToString();

	public CodeBuilder Append(Code c)
	{
		_sb.Append(c.Text);
		return this;
	}

	public CodeBuilder Append(string s)
	{
		_sb.Append(s);
		return this;
	}

	public CodeBuilder Line()
	{
		_sb.Append(_eol);
		return this;
	}

	public CodeBuilder Line(Code c) => IndentIfNeeded().Append(c).Line();
	public CodeBuilder Line(string s) => IndentIfNeeded().Append(s).Line();

	public CodeBuilder Lines(IEnumerable<string> lines)
	{
		foreach (var l in lines) Line(l);
		return this;
	}

	public CodeBuilder Raw(string s)
	{
		_sb.Append(s);
		return this;
	} // no indentation

	public CodeBuilder Raw(Code c)
	{
		_sb.Append(c.Text);
		return this;
	}

	public CodeBuilder Indent()
	{
		_indent++;
		return this;
	}

	public CodeBuilder Outdent()
	{
		if (_indent > 0) _indent--;
		return this;
	}

	public IDisposable ScopedIndent()
	{
		_indent++;
		return new DisposableAction(() => _indent--);
	}

	public CodeBuilder Block(Action<CodeBuilder> body, bool trailingNewLine = true)
	{
		Line(Punct.LBrace);
		using (ScopedIndent())
		{
			body(this);
		}

		Line(Punct.RBrace);
		if (trailingNewLine) Line();
		return this;
	}

	public CodeBuilder HeaderAutoGenerated() => Line("// <auto-generated />").Line();

	public CodeBuilder UsingGlobal(string ns) => Line("global using " + ns + ";");

	public CodeBuilder UsingsGlobal(IEnumerable<string> namespaces)
	{
		foreach (var ns in namespaces.Distinct().OrderBy(n => n))
			UsingGlobal(ns);
		return Line();
	}

	public CodeBuilder Namespace(string ns, Action<CodeBuilder> body)
	{
		Line($"{Keyword.@namespace} {ns}");
		Block(body);
		return this;
	}

	public CodeBuilder Class(string modifiers, string name, Action<CodeBuilder> body)
	{
		Line($"{modifiers} {Keyword.@class} {name}");
		Block(body);
		return this;
	}

	public static Code Join(IEnumerable<Code> parts, Code separator)
	{
		bool first = true;
		var sb = new StringBuilder();
		foreach (var p in parts)
		{
			if (!first) sb.Append(separator.Text);
			sb.Append(p.Text);
			first = false;
		}

		return Code.Of(sb.ToString());
	}

	private CodeBuilder IndentIfNeeded()
	{
		// emit indentation only if we're at start of text or just ended a line
		bool atLineStart = _sb.Length == 0 || _sb[_sb.Length - 1] == '\n';
		if (atLineStart)
		{
			for (int i = 0; i < _indent; i++)
				_sb.Append(_indentUnit);
		}
		return this;
	}

	private sealed class DisposableAction : IDisposable
	{
		private readonly Action _onDispose;
		public DisposableAction(Action onDispose) => _onDispose = onDispose;
		public void Dispose() => _onDispose();
	}
}